package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
) //nolint:depguard

//nolint:gochecknoinits
func init() {
	SchemeBuilder.Register(&Profile{}, &ProfileList{})
}

// apiVersion: ipxe.cloud.alexandre.mahdhaoui.com/v1alpha1
// kind: Profile
// metadata:
//   name: your-profile
//   labels:
//     assign/ipxe/buildarch: aarch64
//     assign/extrinsic/region: us-cal
// spec:
//   # ipxe: string.
//   ipxe: |
//     command ... \
//       --with-parameter "{{ .AdditionalContent.parameter-0 }}" \
//       --ignition-url "{{ .AdditionalContent.ignitionFile }}" \
//       --or-cloud-init "{{ .AdditionalContent.cloudInit }}" \
//       --secret-token "{{ .AdditionalContent.secretToken }}"
//   # additionalContent: []AdditionalContent.
//   additionalContent:
//     - name: parameter-0
//       inline: your parameter
//     # The ignition file will be rendered and exposed behind the `/config/<config-id>` endpoint.
//     # Please note this endpoint can be called with the url parameters of the servers, such as `buildarch`. The config
//     # file can be rendered using those intrinsic (ipxe) variables.
//     - name: ignitionFile
//       exposed: true
//       inline: |
//         YOUR IGNITION CONFIG HERE
//     # Here the cloud-init will not be "exposed", i.e. it will be rendered directly in the template.
//     - name: cloudInit
//       webhook:
//         url: https://example.com/YOUR_ENDPOINT
//         mtlsSecretRef: mySecret
//
// status:
//   # UUIDs that are used to fetch "exposed" files.
//   exposedAdditionalContent:
//     config0: 89952e35-2a85-4f03-a6b2-7f9526bfafc0
//     ignitionFile: 445a4753-3d59-4429-8cea-7db9febdeca

//+kubebuilder:object:root=true
//+kubebuilder:subresources:status

type Profile struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`

	Spec   ProfileSpec   `json:"spec,omitempty"`
	Status ProfileStatus `json:"status,omitempty"`
}

type ProfileSpec struct {
	IPXETemplate string `json:"ipxeTemplate"`

	// AdditionalContent can be templated into the IPXETemplate using the content's key.
	AdditionalContent map[string]AdditionalContent `json:"additionalContent,omitempty"`
}

type ProfileStatus struct{}

//+kubebuilder:object:root=true

type ProfileList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`

	Items []Profile `json:"items"`
}

type (
	AdditionalContent struct {
		// Exposed when set to true will expose the content of the file to `/config/UUID`. The UUID is generated by the
		// operator.
		// When "Exposed", specifying '\{\{ .AdditionalContent.YOUR_CONFIG }}' in other additionalContents or in the ipxe
		// field will be templated as 'https://your.ipxer.com/config/YOUR_CONFIG_UUID'.
		Exposed bool `json:"exposed,omitempty"`

		// PostTransformations is a list of Transformers
		PostTransformations []Transformer `json:"postTransformations"`

		// ObjectRef allow users to specify any reference to a resource holding the desired configuration.
		// Such resources can be ContentMap, Secrets or any other kind of (custom) resources.
		ObjectRef *ObjectRef `json:"objectRef,omitempty"`

		// Inline is used to directly template content from the Custom Resource.
		Inline *string `json:"inline,omitempty"`

		// Webhook is a source type used to allow fetching configurations from any kind of sources, e.g. from an S3
		// bucket.
		Webhook *WebhookConfig `json:"webhook,omitempty"`
	}

	Transformer struct {
		// ButaneToIgnition transforms a butane yaml document into a proper ignition one.
		ButaneToIgnition bool `json:"butaneToIgnition"`

		// Webhook allows users to specify a webhook configuration to a post transformation.
		Webhook *WebhookConfig `json:"webhook,omitempty"`
	}

	ObjectRef struct {
		ResourceRef `json:",inline"`

		// JSONPath to the desired content in the resource using jsonpath notation. E.g. `.data.private\.key`
		// TODO: Validate this jsonpath in the webhook.
		JSONPath string `json:"jsonpath"`
	}

	WebhookConfig struct {
		URL string `json:"url"`

		MTLSObjectRef      *MTLSObjectRef      `json:"mTLSRef,omitempty"`
		BasicAuthObjectRef *BasicAuthObjectRef `json:"basicAuthRef,omitempty"`
	}

	BasicAuthObjectRef struct {
		ResourceRef `json:",inline"`

		// UsernameJSONPath to the desired content in the resource using jsonpath notation. E.g. `.data.username`
		UsernameJSONPath string `json:"usernameJSONPath"`

		// PasswordJSONPath to the desired content in the resource using jsonpath notation. E.g. `.data.password`
		PasswordJSONPath string `json:"passwordJSONPath"`
	}

	MTLSObjectRef struct {
		ResourceRef `json:",inline"`

		// ClientKeyJSONPath to the desired content in the resource using jsonpath notation. E.g. `.data.'client.key'`
		ClientKeyJSONPath string `json:"clientKeyJSONPath"`

		// ClientCertJSONPath to the desired content in the resource using jsonpath notation. E.g. `.data.'client.crt'`
		ClientCertJSONPath string `json:"clientCertJSONPath"`

		// CaBundleJSONPath to the desired content in the resource using jsonpath notation. E.g. `.data.'ca-bundle.pem'`
		CaBundleJSONPath string `json:"caBundleJSONPath,omitempty"`

		// TLSInsecureSkipVerify allow usage of self-signed certificates.
		TLSInsecureSkipVerify bool `json:"tlsInsecureSkipVerify"`
	}
)

// ResourceRef unambiguously identifies a resource. It doesn't anonymously include GroupVersion to avoid
// automatic coercion. It doesn't use a GroupVersion to avoid custom marshalling.
type ResourceRef struct {
	// Group is the group of the apiVersion.
	Group string `json:"group"`
	// Version is the version of the apiVersion.
	Version string `json:"version"`
	// Resource is the kind of the resource.
	Resource string `json:"resource"`
	// Namespace is the namespace of the resource
	Namespace string `json:"namespace"`
	// Name is the name of the resource.
	Name string `json:"name"`
}
